//! Generated by `cargo xtask gen grammar`, do not edit by hand.

#![allow(bad_style, dead_code, missing_docs, unreachable_pub)]
#[doc = r" The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT`."]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    AMP,
    AT,
    BANG,
    COLON,
    COMMA,
    DOLLAR,
    DOT,
    DOTDOT,
    DOTDOTDOT,
    DOTDOTEQ,
    DOTRO,
    EQ,
    EQEQ,
    EQEQEQ,
    FAT_ARROW,
    LTEQ,
    L_ANGLE,
    L_BRACK,
    L_CURLY,
    L_PAREN,
    MINUS,
    NEQ,
    NEQEQ,
    PERCENT,
    PIPE,
    PLUS,
    POUND,
    QUESTION,
    R_ANGLE,
    R_BRACK,
    R_CURLY,
    R_PAREN,
    SECSEP,
    SEMICOLON,
    SLASH,
    STAR,
    THIN_ARROW,
    TILDE,
    UNDERSCORE,
    SELF_TYPE_KW,
    AND_KW,
    AS_KW,
    ASYNC_KW,
    AWAIT_KW,
    BREAK_KW,
    CONTINUE_KW,
    CRATE_KW,
    ELSE_KW,
    ENUM_KW,
    FALSE_KW,
    FN_KW,
    FOR_KW,
    FROM_KW,
    IF_KW,
    IMPL_KW,
    IN_KW,
    LET_KW,
    LOOP_KW,
    MATCH_KW,
    MUT_KW,
    NEVER_KW,
    NOT_KW,
    OR_KW,
    PUB_KW,
    RETURN_KW,
    SELF_KW,
    SHOW_KW,
    SUPER_KW,
    TRAIT_KW,
    TRUE_KW,
    TRY_KW,
    TYPE_KW,
    USE_KW,
    WHERE_KW,
    WHILE_KW,
    BYTE,
    CHAR,
    FLOAT_NUMBER,
    INT_NUMBER,
    RAW_STRING,
    STRING,
    COMMENT,
    ERROR,
    IDENT,
    NEWLINE,
    WHITESPACE,
    ALIASED_TUPLE_PAT,
    ARG,
    ARG_LIST,
    ASSOC_ITEM_LIST,
    ASSOC_TYPE_ARG,
    ASYNC_EXPR,
    ATTR,
    AWAIT_EXPR,
    BIN_EXPR,
    BLOCK_EXPR,
    BREAK_EXPR,
    CALL_EXPR,
    CAST_EXPR,
    CLOSURE_EXPR,
    CODE_ITEM,
    CODE_SECTION,
    CONST_ARG,
    CONTINUE_EXPR,
    DEP,
    DEP_PATH,
    DEP_PATH_SEGMENT,
    ENUM,
    EXPR,
    EXPR_STMT,
    EXTERNAL_DEP_PATH,
    FIELD_EXPR,
    FIELD_LIST,
    FN,
    FN_PTR_TYPE,
    FN_REF_EXPR,
    FOR_EXPR,
    GENERIC_ARG,
    GENERIC_ARG_LIST,
    GENERIC_PARAM,
    GENERIC_PARAM_LIST,
    IDENT_PAT,
    IF_EXPR,
    IMPL,
    INDEX_EXPR,
    INFER_TYPE,
    LET_EXPR,
    LET_STMT,
    LIST_ENTRY,
    LIST_EXPR,
    LIST_TYPE,
    LITERAL,
    LITERAL_PAT,
    LOCAL_DEP_PATH,
    LOOP_EXPR,
    MAP_ENTRY,
    MAP_EXPR,
    MAP_TYPE,
    MATCH_ARM,
    MATCH_ARM_LIST,
    MATCH_EXPR,
    MATCH_GUARD,
    MAYBE_SELFIFIED_ARG,
    META,
    META_SECTION,
    METHOD_CALL_ARG_LIST,
    METHOD_CALL_EXPR,
    MUT_EXPR,
    MUT_TYPE,
    NAME,
    NAME_REF,
    NEG_EXPR,
    NEVER_TYPE,
    NOT_EXPR,
    OPTION_TYPE,
    OR_PAT,
    PARAM,
    PARAM_LIST,
    PARENT_DIR_DEP_PATH_SEGMENT,
    PAREN_EXPR,
    PAREN_PAT,
    PAREN_TYPE,
    PAT,
    PATH,
    PATH_EXPR,
    PATH_PAT,
    PATH_SEGMENT,
    PATH_TYPE,
    RANGE_EXPR,
    RANGE_PAT,
    RECORD_EXPR,
    RECORD_EXPR_FIELD,
    RECORD_EXPR_FIELD_LIST,
    RECORD_FIELD,
    RECORD_FIELD_LIST,
    RECORD_PAT,
    RECORD_PAT_FIELD,
    RECORD_TYPE,
    RECORD_TYPE_FIELD,
    RENAME,
    REPO_DEP_PATH,
    REST_PAT,
    RESULT_TYPE,
    RETURN_EXPR,
    RET_TYPE,
    SELF_PARAM,
    SET_ENTRY,
    SET_EXPR,
    SET_TYPE,
    SLICE_PAT,
    SLICE_TYPE,
    SOURCE_FILE,
    STMT,
    STMT_LIST,
    TOKEN_TREE,
    TRAIT,
    TRY_EXPR,
    TUPLE_EXPR,
    TUPLE_FIELD,
    TUPLE_FIELD_LIST,
    TUPLE_PAT,
    TUPLE_TYPE,
    TYPE,
    TYPE_ALIAS,
    TYPE_ARG,
    TYPE_BOUND,
    TYPE_BOUND_LIST,
    TYPE_PARAM,
    UNDERSCORE_EXPR,
    UNION_TYPE,
    UNKNOWN_TYPE,
    USE,
    USE_TREE,
    USE_TREE_EXPANSION,
    USE_TREE_LIST,
    VARIANT,
    VARIANT_LIST,
    VISIBILITY,
    WHERE_CLAUSE,
    WHERE_PRED,
    WHILE_EXPR,
    WILDCARD_PAT,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    #[doc = r" Checks whether this syntax kind is a strict keyword for the given edition."]
    #[doc = r" Strict keywords are identifiers that are always considered keywords."]
    pub fn is_strict_keyword(self) -> bool {
        matches!(
            self,
            SELF_TYPE_KW
                | AND_KW
                | AS_KW
                | ASYNC_KW
                | AWAIT_KW
                | BREAK_KW
                | CONTINUE_KW
                | CRATE_KW
                | ELSE_KW
                | ENUM_KW
                | FALSE_KW
                | FN_KW
                | FOR_KW
                | FROM_KW
                | IF_KW
                | IMPL_KW
                | IN_KW
                | LET_KW
                | LOOP_KW
                | MATCH_KW
                | MUT_KW
                | NEVER_KW
                | NOT_KW
                | OR_KW
                | PUB_KW
                | RETURN_KW
                | SELF_KW
                | SHOW_KW
                | SUPER_KW
                | TRAIT_KW
                | TRUE_KW
                | TRY_KW
                | TYPE_KW
                | USE_KW
                | WHERE_KW
                | WHILE_KW
        )
    }
    #[doc = r" Checks whether this syntax kind is a strict or weak keyword for the given edition."]
    pub fn is_keyword(self) -> bool {
        matches!(
            self,
            SELF_TYPE_KW
                | AND_KW
                | AS_KW
                | ASYNC_KW
                | AWAIT_KW
                | BREAK_KW
                | CONTINUE_KW
                | CRATE_KW
                | ELSE_KW
                | ENUM_KW
                | FALSE_KW
                | FN_KW
                | FOR_KW
                | FROM_KW
                | IF_KW
                | IMPL_KW
                | IN_KW
                | LET_KW
                | LOOP_KW
                | MATCH_KW
                | MUT_KW
                | NEVER_KW
                | NOT_KW
                | OR_KW
                | PUB_KW
                | RETURN_KW
                | SELF_KW
                | SHOW_KW
                | SUPER_KW
                | TRAIT_KW
                | TRUE_KW
                | TRY_KW
                | TYPE_KW
                | USE_KW
                | WHERE_KW
                | WHILE_KW
        )
    }
    pub fn is_punct(self) -> bool {
        matches!(
            self,
            AMP | AT
                | BANG
                | COLON
                | COMMA
                | DOLLAR
                | DOT
                | DOTDOT
                | DOTDOTDOT
                | DOTDOTEQ
                | DOTRO
                | EQ
                | EQEQ
                | EQEQEQ
                | FAT_ARROW
                | LTEQ
                | L_ANGLE
                | L_BRACK
                | L_CURLY
                | L_PAREN
                | MINUS
                | NEQ
                | NEQEQ
                | PERCENT
                | PIPE
                | PLUS
                | POUND
                | QUESTION
                | R_ANGLE
                | R_BRACK
                | R_CURLY
                | R_PAREN
                | SECSEP
                | SEMICOLON
                | SLASH
                | STAR
                | THIN_ARROW
                | TILDE
                | UNDERSCORE
        )
    }
    pub fn is_literal(self) -> bool {
        matches!(
            self,
            BYTE | CHAR | FLOAT_NUMBER | INT_NUMBER | RAW_STRING | STRING
        )
    }
    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "Self" => SELF_TYPE_KW,
            "and" => AND_KW,
            "as" => AS_KW,
            "async" => ASYNC_KW,
            "await" => AWAIT_KW,
            "break" => BREAK_KW,
            "continue" => CONTINUE_KW,
            "crate" => CRATE_KW,
            "else" => ELSE_KW,
            "enum" => ENUM_KW,
            "false" => FALSE_KW,
            "fn" => FN_KW,
            "for" => FOR_KW,
            "from" => FROM_KW,
            "if" => IF_KW,
            "impl" => IMPL_KW,
            "in" => IN_KW,
            "let" => LET_KW,
            "loop" => LOOP_KW,
            "match" => MATCH_KW,
            "mut" => MUT_KW,
            "never" => NEVER_KW,
            "not" => NOT_KW,
            "or" => OR_KW,
            "pub" => PUB_KW,
            "return" => RETURN_KW,
            "self" => SELF_KW,
            "show" => SHOW_KW,
            "super" => SUPER_KW,
            "trait" => TRAIT_KW,
            "true" => TRUE_KW,
            "try" => TRY_KW,
            "type" => TYPE_KW,
            "use" => USE_KW,
            "where" => WHERE_KW,
            "while" => WHILE_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            '&' => AMP,
            '@' => AT,
            '!' => BANG,
            ':' => COLON,
            ',' => COMMA,
            '$' => DOLLAR,
            '.' => DOT,
            '=' => EQ,
            '<' => L_ANGLE,
            '[' => L_BRACK,
            '{' => L_CURLY,
            '(' => L_PAREN,
            '-' => MINUS,
            '%' => PERCENT,
            '|' => PIPE,
            '+' => PLUS,
            '#' => POUND,
            '?' => QUESTION,
            '>' => R_ANGLE,
            ']' => R_BRACK,
            '}' => R_CURLY,
            ')' => R_PAREN,
            ';' => SEMICOLON,
            '/' => SLASH,
            '*' => STAR,
            '~' => TILDE,
            '_' => UNDERSCORE,
            _ => return None,
        };
        Some(tok)
    }
}
#[macro_export]
macro_rules ! T { [&] => { $ crate :: SyntaxKind :: AMP } ; [@] => { $ crate :: SyntaxKind :: AT } ; [!] => { $ crate :: SyntaxKind :: BANG } ; [:] => { $ crate :: SyntaxKind :: COLON } ; [,] => { $ crate :: SyntaxKind :: COMMA } ; [$] => { $ crate :: SyntaxKind :: DOLLAR } ; [.] => { $ crate :: SyntaxKind :: DOT } ; [..] => { $ crate :: SyntaxKind :: DOTDOT } ; [...] => { $ crate :: SyntaxKind :: DOTDOTDOT } ; [..=] => { $ crate :: SyntaxKind :: DOTDOTEQ } ; [::] => { $ crate :: SyntaxKind :: DOTRO } ; [=] => { $ crate :: SyntaxKind :: EQ } ; [==] => { $ crate :: SyntaxKind :: EQEQ } ; [===] => { $ crate :: SyntaxKind :: EQEQEQ } ; [=>] => { $ crate :: SyntaxKind :: FAT_ARROW } ; [<=] => { $ crate :: SyntaxKind :: LTEQ } ; [<] => { $ crate :: SyntaxKind :: L_ANGLE } ; ['['] => { $ crate :: SyntaxKind :: L_BRACK } ; ['{'] => { $ crate :: SyntaxKind :: L_CURLY } ; ['('] => { $ crate :: SyntaxKind :: L_PAREN } ; [-] => { $ crate :: SyntaxKind :: MINUS } ; [!=] => { $ crate :: SyntaxKind :: NEQ } ; [!==] => { $ crate :: SyntaxKind :: NEQEQ } ; [%] => { $ crate :: SyntaxKind :: PERCENT } ; [|] => { $ crate :: SyntaxKind :: PIPE } ; [+] => { $ crate :: SyntaxKind :: PLUS } ; [#] => { $ crate :: SyntaxKind :: POUND } ; [?] => { $ crate :: SyntaxKind :: QUESTION } ; [>] => { $ crate :: SyntaxKind :: R_ANGLE } ; [']'] => { $ crate :: SyntaxKind :: R_BRACK } ; ['}'] => { $ crate :: SyntaxKind :: R_CURLY } ; [')'] => { $ crate :: SyntaxKind :: R_PAREN } ; [---] => { $ crate :: SyntaxKind :: SECSEP } ; [;] => { $ crate :: SyntaxKind :: SEMICOLON } ; [/] => { $ crate :: SyntaxKind :: SLASH } ; [*] => { $ crate :: SyntaxKind :: STAR } ; [->] => { $ crate :: SyntaxKind :: THIN_ARROW } ; [~] => { $ crate :: SyntaxKind :: TILDE } ; [_] => { $ crate :: SyntaxKind :: UNDERSCORE } ; [Self] => { $ crate :: SyntaxKind :: SELF_TYPE_KW } ; [and] => { $ crate :: SyntaxKind :: AND_KW } ; [as] => { $ crate :: SyntaxKind :: AS_KW } ; [async] => { $ crate :: SyntaxKind :: ASYNC_KW } ; [await] => { $ crate :: SyntaxKind :: AWAIT_KW } ; [break] => { $ crate :: SyntaxKind :: BREAK_KW } ; [continue] => { $ crate :: SyntaxKind :: CONTINUE_KW } ; [crate] => { $ crate :: SyntaxKind :: CRATE_KW } ; [else] => { $ crate :: SyntaxKind :: ELSE_KW } ; [enum] => { $ crate :: SyntaxKind :: ENUM_KW } ; [false] => { $ crate :: SyntaxKind :: FALSE_KW } ; [fn] => { $ crate :: SyntaxKind :: FN_KW } ; [for] => { $ crate :: SyntaxKind :: FOR_KW } ; [from] => { $ crate :: SyntaxKind :: FROM_KW } ; [if] => { $ crate :: SyntaxKind :: IF_KW } ; [impl] => { $ crate :: SyntaxKind :: IMPL_KW } ; [in] => { $ crate :: SyntaxKind :: IN_KW } ; [let] => { $ crate :: SyntaxKind :: LET_KW } ; [loop] => { $ crate :: SyntaxKind :: LOOP_KW } ; [match] => { $ crate :: SyntaxKind :: MATCH_KW } ; [mut] => { $ crate :: SyntaxKind :: MUT_KW } ; [never] => { $ crate :: SyntaxKind :: NEVER_KW } ; [not] => { $ crate :: SyntaxKind :: NOT_KW } ; [or] => { $ crate :: SyntaxKind :: OR_KW } ; [pub] => { $ crate :: SyntaxKind :: PUB_KW } ; [return] => { $ crate :: SyntaxKind :: RETURN_KW } ; [self] => { $ crate :: SyntaxKind :: SELF_KW } ; [show] => { $ crate :: SyntaxKind :: SHOW_KW } ; [super] => { $ crate :: SyntaxKind :: SUPER_KW } ; [trait] => { $ crate :: SyntaxKind :: TRAIT_KW } ; [true] => { $ crate :: SyntaxKind :: TRUE_KW } ; [try] => { $ crate :: SyntaxKind :: TRY_KW } ; [type] => { $ crate :: SyntaxKind :: TYPE_KW } ; [use] => { $ crate :: SyntaxKind :: USE_KW } ; [where] => { $ crate :: SyntaxKind :: WHERE_KW } ; [while] => { $ crate :: SyntaxKind :: WHILE_KW } ; [lifetime_ident] => { $ crate :: SyntaxKind :: LIFETIME_IDENT } ; [int_number] => { $ crate :: SyntaxKind :: INT_NUMBER } ; [ident] => { $ crate :: SyntaxKind :: IDENT } ; [string] => { $ crate :: SyntaxKind :: STRING } ; [shebang] => { $ crate :: SyntaxKind :: SHEBANG } ; }
