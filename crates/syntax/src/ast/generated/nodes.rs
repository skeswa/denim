//! Generated by `cargo xtask gen grammar`, do not edit by hand.

#![allow(non_snake_case)]
use crate::{
    ast::{self, support, AstChildren, AstNode},
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken, T,
};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AliasedTuplePat {
    pub(crate) syntax: SyntaxNode,
}
impl AliasedTuplePat {
    #[inline]
    pub fn fields(&self) -> AstChildren<Pat> { support::children(&self.syntax) }
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Arg {
    pub(crate) syntax: SyntaxNode,
}
impl Arg {
    #[inline]
    pub fn label(&self) -> Option<Name> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArgList {
    pub(crate) syntax: SyntaxNode,
}
impl ArgList {
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssocItemList {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for AssocItemList {}
impl AssocItemList {
    #[inline]
    pub fn fns(&self) -> AstChildren<Fn> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssocTypeArg {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasGenericArgs for AssocTypeArg {}
impl ast::HasTypeBounds for AssocTypeArg {}
impl AssocTypeArg {
    #[inline]
    pub fn const_arg(&self) -> Option<ConstArg> { support::child(&self.syntax) }
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AsyncExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for AsyncExpr {}
impl AsyncExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }
    #[inline]
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Attr {
    pub(crate) syntax: SyntaxNode,
}
impl Attr {
    #[inline]
    pub fn meta(&self) -> Option<Meta> { support::child(&self.syntax) }
    #[inline]
    pub fn bang_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }
    #[inline]
    pub fn pound_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![#]) }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AwaitExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for AwaitExpr {}
impl AwaitExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }
    #[inline]
    pub fn await_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![await]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for BinExpr {}
impl BinExpr {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for BlockExpr {}
impl BlockExpr {
    #[inline]
    pub fn stmt_list(&self) -> Option<StmtList> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for BreakExpr {}
impl BreakExpr {
    #[inline]
    pub fn break_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![break]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasArgList for CallExpr {}
impl ast::HasAttrs for CallExpr {}
impl CallExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CastExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for CastExpr {}
impl CastExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }
    #[inline]
    pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClosureExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for ClosureExpr {}
impl ClosureExpr {
    #[inline]
    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CodeSection {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for CodeSection {}
impl ast::HasDocComments for CodeSection {}
impl CodeSection {
    #[inline]
    pub fn code_items(&self) -> AstChildren<CodeItem> { support::children(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstArg {
    pub(crate) syntax: SyntaxNode,
}
impl ConstArg {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for ContinueExpr {}
impl ContinueExpr {
    #[inline]
    pub fn continue_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![continue])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Dep {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Dep {}
impl Dep {
    #[inline]
    pub fn dep_path(&self) -> Option<DepPath> { support::child(&self.syntax) }
    #[inline]
    pub fn use_or_show(&self) -> Option<Use> { support::child(&self.syntax) }
    #[inline]
    pub fn from_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![from]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DepPathSegment {
    pub(crate) syntax: SyntaxNode,
}
impl DepPathSegment {
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn slash_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![/]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Enum {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Enum {}
impl ast::HasDocComments for Enum {}
impl ast::HasGenericParams for Enum {}
impl ast::HasName for Enum {}
impl ast::HasVisibility for Enum {}
impl Enum {
    #[inline]
    pub fn variant_list(&self) -> Option<VariantList> { support::child(&self.syntax) }
    #[inline]
    pub fn enum_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![enum]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ExprStmt {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExternalDepPath {
    pub(crate) syntax: SyntaxNode,
}
impl ExternalDepPath {
    #[inline]
    pub fn qualifier(&self) -> Option<ExternalDepPath> { support::child(&self.syntax) }
    #[inline]
    pub fn segment(&self) -> Option<DepPathSegment> { support::child(&self.syntax) }
    #[inline]
    pub fn slash_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![/]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FieldExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for FieldExpr {}
impl FieldExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Fn {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Fn {}
impl ast::HasDocComments for Fn {}
impl ast::HasGenericParams for Fn {}
impl ast::HasName for Fn {}
impl ast::HasVisibility for Fn {}
impl Fn {
    #[inline]
    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn fn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fn]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnPtrType {
    pub(crate) syntax: SyntaxNode,
}
impl FnPtrType {
    #[inline]
    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }
    #[inline]
    pub fn fn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fn]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnRefExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for FnRefExpr {}
impl FnRefExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }
    #[inline]
    pub fn fn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fn]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for ForExpr {}
impl ForExpr {
    #[inline]
    pub fn loop_body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }
    #[inline]
    pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }
    #[inline]
    pub fn in_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![in]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GenericArgList {
    pub(crate) syntax: SyntaxNode,
}
impl GenericArgList {
    #[inline]
    pub fn generic_args(&self) -> AstChildren<GenericArg> { support::children(&self.syntax) }
    #[inline]
    pub fn dotro_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }
    #[inline]
    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }
    #[inline]
    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GenericParam {
    pub(crate) syntax: SyntaxNode,
}
impl GenericParam {
    #[inline]
    pub fn type_param(&self) -> Option<TypeParam> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GenericParamList {
    pub(crate) syntax: SyntaxNode,
}
impl GenericParamList {
    #[inline]
    pub fn generic_params(&self) -> AstChildren<GenericParam> { support::children(&self.syntax) }
    #[inline]
    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }
    #[inline]
    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentPat {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for IdentPat {}
impl ast::HasName for IdentPat {}
impl IdentPat {
    #[inline]
    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }
    #[inline]
    pub fn at_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![@]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for IfExpr {}
impl IfExpr {
    #[inline]
    pub fn else_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![else]) }
    #[inline]
    pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Impl {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Impl {}
impl ast::HasDocComments for Impl {}
impl ast::HasGenericParams for Impl {}
impl ast::HasVisibility for Impl {}
impl Impl {
    #[inline]
    pub fn assoc_item_list(&self) -> Option<AssocItemList> { support::child(&self.syntax) }
    #[inline]
    pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }
    #[inline]
    pub fn impl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![impl]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for IndexExpr {}
impl IndexExpr {
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InferType {
    pub(crate) syntax: SyntaxNode,
}
impl InferType {
    #[inline]
    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for LetExpr {}
impl LetExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
    #[inline]
    pub fn let_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![let]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for LetStmt {}
impl LetStmt {
    #[inline]
    pub fn initializer(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
    #[inline]
    pub fn let_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![let]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListEntry {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for ListEntry {}
impl ListEntry {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn spread(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for ListExpr {}
impl ListExpr {
    #[inline]
    pub fn list_entrys(&self) -> AstChildren<ListEntry> { support::children(&self.syntax) }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListType {
    pub(crate) syntax: SyntaxNode,
}
impl ListType {
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Literal {}
impl Literal {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralPat {
    pub(crate) syntax: SyntaxNode,
}
impl LiteralPat {
    #[inline]
    pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }
    #[inline]
    pub fn minus_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![-]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LocalDepPath {
    pub(crate) syntax: SyntaxNode,
}
impl LocalDepPath {
    #[inline]
    pub fn external_dep_path(&self) -> Option<ExternalDepPath> { support::child(&self.syntax) }
    #[inline]
    pub fn parent_dir_dep_path_segment(&self) -> Option<ParentDirDepPathSegment> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn parent_dir_dep_path_segments(&self) -> AstChildren<ParentDirDepPathSegment> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }
    #[inline]
    pub fn slash_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![/]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LoopExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for LoopExpr {}
impl LoopExpr {
    #[inline]
    pub fn loop_body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn loop_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![loop]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MapEntry {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for MapEntry {}
impl MapEntry {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn spread(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MapExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for MapExpr {}
impl MapExpr {
    #[inline]
    pub fn map_entrys(&self) -> AstChildren<MapEntry> { support::children(&self.syntax) }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MapType {
    pub(crate) syntax: SyntaxNode,
}
impl MapType {
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArm {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for MatchArm {}
impl MatchArm {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn guard(&self) -> Option<MatchGuard> { support::child(&self.syntax) }
    #[inline]
    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }
    #[inline]
    pub fn comma_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![,]) }
    #[inline]
    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=>]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArmList {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for MatchArmList {}
impl MatchArmList {
    #[inline]
    pub fn arms(&self) -> AstChildren<MatchArm> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for MatchExpr {}
impl MatchExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn match_arm_list(&self) -> Option<MatchArmList> { support::child(&self.syntax) }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }
    #[inline]
    pub fn match_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![match]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchGuard {
    pub(crate) syntax: SyntaxNode,
}
impl MatchGuard {
    #[inline]
    pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MaybeSelfifiedArg {
    pub(crate) syntax: SyntaxNode,
}
impl MaybeSelfifiedArg {
    #[inline]
    pub fn arg(&self) -> Option<Arg> { support::child(&self.syntax) }
    #[inline]
    pub fn self_label(&self) -> Option<Name> { support::child(&self.syntax) }
    #[inline]
    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Meta {
    pub(crate) syntax: SyntaxNode,
}
impl Meta {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
    #[inline]
    pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
    #[inline]
    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MetaSection {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for MetaSection {}
impl ast::HasDocComments for MetaSection {}
impl MetaSection {
    #[inline]
    pub fn deps(&self) -> AstChildren<Dep> { support::children(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodCallArgList {
    pub(crate) syntax: SyntaxNode,
}
impl MethodCallArgList {
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodCallExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for MethodCallExpr {}
impl ast::HasGenericArgs for MethodCallExpr {}
impl MethodCallExpr {
    #[inline]
    pub fn method_call_arg_list(&self) -> Option<MethodCallArgList> { support::child(&self.syntax) }
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn receiver(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MutExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for MutExpr {}
impl MutExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }
    #[inline]
    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MutType {
    pub(crate) syntax: SyntaxNode,
}
impl MutType {
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}
impl Name {
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }
    #[inline]
    pub fn self_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![self]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameRef {
    pub(crate) syntax: SyntaxNode,
}
impl NameRef {
    #[inline]
    pub fn Self_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![Self]) }
    #[inline]
    pub fn crate_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![crate]) }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }
    #[inline]
    pub fn int_number_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![int_number])
    }
    #[inline]
    pub fn self_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![self]) }
    #[inline]
    pub fn super_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![super]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NegExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for NegExpr {}
impl NegExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn minus_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![-]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NeverType {
    pub(crate) syntax: SyntaxNode,
}
impl NeverType {
    #[inline]
    pub fn never_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![never]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NotExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for NotExpr {}
impl NotExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }
    #[inline]
    pub fn not_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![not]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OptionType {
    pub(crate) syntax: SyntaxNode,
}
impl OptionType {
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn question_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![?]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OrPat {
    pub(crate) syntax: SyntaxNode,
}
impl OrPat {
    #[inline]
    pub fn pats(&self) -> AstChildren<Pat> { support::children(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Param {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Param {}
impl Param {
    #[inline]
    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn dotdotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![...]) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParamList {
    pub(crate) syntax: SyntaxNode,
}
impl ParamList {
    #[inline]
    pub fn params(&self) -> AstChildren<Param> { support::children(&self.syntax) }
    #[inline]
    pub fn self_param(&self) -> Option<SelfParam> { support::child(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    #[inline]
    pub fn comma_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![,]) }
    #[inline]
    pub fn pipe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![|]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for ParenExpr {}
impl ParenExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenPat {
    pub(crate) syntax: SyntaxNode,
}
impl ParenPat {
    #[inline]
    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenType {
    pub(crate) syntax: SyntaxNode,
}
impl ParenType {
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParentDirDepPathSegment {
    pub(crate) syntax: SyntaxNode,
}
impl ParentDirDepPathSegment {
    #[inline]
    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }
    #[inline]
    pub fn slash_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![/]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Path {
    pub(crate) syntax: SyntaxNode,
}
impl Path {
    #[inline]
    pub fn qualifier(&self) -> Option<Path> { support::child(&self.syntax) }
    #[inline]
    pub fn segment(&self) -> Option<PathSegment> { support::child(&self.syntax) }
    #[inline]
    pub fn dotro_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for PathExpr {}
impl PathExpr {
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathPat {
    pub(crate) syntax: SyntaxNode,
}
impl PathPat {
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathSegment {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasGenericArgs for PathSegment {}
impl PathSegment {
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }
    #[inline]
    pub fn path_type(&self) -> Option<PathType> { support::child(&self.syntax) }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn dotro_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }
    #[inline]
    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }
    #[inline]
    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }
    #[inline]
    pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathType {
    pub(crate) syntax: SyntaxNode,
}
impl PathType {
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for RangeExpr {}
impl RangeExpr {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangePat {
    pub(crate) syntax: SyntaxNode,
}
impl RangePat {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordExpr {
    pub(crate) syntax: SyntaxNode,
}
impl RecordExpr {
    #[inline]
    pub fn record_expr_field_list(&self) -> Option<RecordExprFieldList> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordExprField {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for RecordExprField {}
impl RecordExprField {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordExprFieldList {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for RecordExprFieldList {}
impl RecordExprFieldList {
    #[inline]
    pub fn fields(&self) -> AstChildren<RecordExprField> { support::children(&self.syntax) }
    #[inline]
    pub fn spread(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
    #[inline]
    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordField {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for RecordField {}
impl ast::HasDocComments for RecordField {}
impl ast::HasName for RecordField {}
impl RecordField {
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordFieldList {
    pub(crate) syntax: SyntaxNode,
}
impl RecordFieldList {
    #[inline]
    pub fn fields(&self) -> AstChildren<RecordField> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordPat {
    pub(crate) syntax: SyntaxNode,
}
impl RecordPat {
    #[inline]
    pub fn fields(&self) -> AstChildren<RecordPatField> { support::children(&self.syntax) }
    #[inline]
    pub fn rest_pat(&self) -> Option<RestPat> { support::child(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordPatField {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for RecordPatField {}
impl RecordPatField {
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordType {
    pub(crate) syntax: SyntaxNode,
}
impl RecordType {
    #[inline]
    pub fn fields(&self) -> AstChildren<RecordTypeField> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordTypeField {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for RecordTypeField {}
impl ast::HasDocComments for RecordTypeField {}
impl ast::HasName for RecordTypeField {}
impl RecordTypeField {
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Rename {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for Rename {}
impl Rename {
    #[inline]
    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }
    #[inline]
    pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RepoDepPath {
    pub(crate) syntax: SyntaxNode,
}
impl RepoDepPath {
    #[inline]
    pub fn external_dep_path(&self) -> Option<ExternalDepPath> { support::child(&self.syntax) }
    #[inline]
    pub fn slash_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![/]) }
    #[inline]
    pub fn tilde_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![~]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RestPat {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for RestPat {}
impl RestPat {
    #[inline]
    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ResultType {
    pub(crate) syntax: SyntaxNode,
}
impl ResultType {
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn bang_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RetType {
    pub(crate) syntax: SyntaxNode,
}
impl RetType {
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn thin_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![->]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for ReturnExpr {}
impl ReturnExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn return_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![return]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelfParam {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for SelfParam {}
impl ast::HasName for SelfParam {}
impl SelfParam {
    #[inline]
    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SetEntry {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for SetEntry {}
impl SetEntry {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn spread(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SetExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for SetExpr {}
impl SetExpr {
    #[inline]
    pub fn set_entrys(&self) -> AstChildren<SetEntry> { support::children(&self.syntax) }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SetType {
    pub(crate) syntax: SyntaxNode,
}
impl SetType {
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SlicePat {
    pub(crate) syntax: SyntaxNode,
}
impl SlicePat {
    #[inline]
    pub fn pats(&self) -> AstChildren<Pat> { support::children(&self.syntax) }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SliceType {
    pub(crate) syntax: SyntaxNode,
}
impl SliceType {
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}
impl SourceFile {
    #[inline]
    pub fn code(&self) -> Option<CodeSection> { support::child(&self.syntax) }
    #[inline]
    pub fn meta(&self) -> Option<MetaSection> { support::child(&self.syntax) }
    #[inline]
    pub fn secsep_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![---]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StmtList {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for StmtList {}
impl StmtList {
    #[inline]
    pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }
    #[inline]
    pub fn tail_expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TokenTree {
    pub(crate) syntax: SyntaxNode,
}
impl TokenTree {
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Trait {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Trait {}
impl ast::HasDocComments for Trait {}
impl ast::HasGenericParams for Trait {}
impl ast::HasName for Trait {}
impl ast::HasTypeBounds for Trait {}
impl ast::HasVisibility for Trait {}
impl Trait {
    #[inline]
    pub fn assoc_item_list(&self) -> Option<AssocItemList> { support::child(&self.syntax) }
    #[inline]
    pub fn trait_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![trait]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for TryExpr {}
impl TryExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }
    #[inline]
    pub fn try_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![try]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for TupleExpr {}
impl TupleExpr {
    #[inline]
    pub fn fields(&self) -> AstChildren<Expr> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleField {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for TupleField {}
impl ast::HasDocComments for TupleField {}
impl ast::HasVisibility for TupleField {}
impl TupleField {
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleFieldList {
    pub(crate) syntax: SyntaxNode,
}
impl TupleFieldList {
    #[inline]
    pub fn fields(&self) -> AstChildren<TupleField> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TuplePat {
    pub(crate) syntax: SyntaxNode,
}
impl TuplePat {
    #[inline]
    pub fn fields(&self) -> AstChildren<Pat> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleType {
    pub(crate) syntax: SyntaxNode,
}
impl TupleType {
    #[inline]
    pub fn fields(&self) -> AstChildren<Type> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeAlias {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for TypeAlias {}
impl ast::HasDocComments for TypeAlias {}
impl ast::HasGenericParams for TypeAlias {}
impl ast::HasName for TypeAlias {}
impl ast::HasTypeBounds for TypeAlias {}
impl ast::HasVisibility for TypeAlias {}
impl TypeAlias {
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
    #[inline]
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![type]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeArg {
    pub(crate) syntax: SyntaxNode,
}
impl TypeArg {
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeBound {
    pub(crate) syntax: SyntaxNode,
}
impl TypeBound {
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeBoundList {
    pub(crate) syntax: SyntaxNode,
}
impl TypeBoundList {
    #[inline]
    pub fn bounds(&self) -> AstChildren<TypeBound> { support::children(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParam {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for TypeParam {}
impl ast::HasName for TypeParam {}
impl ast::HasTypeBounds for TypeParam {}
impl TypeParam {
    #[inline]
    pub fn default_type(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnderscoreExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for UnderscoreExpr {}
impl UnderscoreExpr {
    #[inline]
    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnionType {
    pub(crate) syntax: SyntaxNode,
}
impl UnionType {
    #[inline]
    pub fn types(&self) -> AstChildren<Type> { support::children(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnknownType {
    pub(crate) syntax: SyntaxNode,
}
impl UnknownType {
    #[inline]
    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![*]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Use {
    pub(crate) syntax: SyntaxNode,
}
impl Use {
    #[inline]
    pub fn use_tree_list(&self) -> Option<UseTreeList> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn show_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![show]) }
    #[inline]
    pub fn use_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![use]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseTree {
    pub(crate) syntax: SyntaxNode,
}
impl UseTree {
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
    #[inline]
    pub fn rename(&self) -> Option<Rename> { support::child(&self.syntax) }
    #[inline]
    pub fn use_tree_expansion(&self) -> Option<UseTreeExpansion> { support::child(&self.syntax) }
    #[inline]
    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![*]) }
    #[inline]
    pub fn dotro_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseTreeExpansion {
    pub(crate) syntax: SyntaxNode,
}
impl UseTreeExpansion {
    #[inline]
    pub fn use_tree_list(&self) -> Option<UseTreeList> { support::child(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseTreeList {
    pub(crate) syntax: SyntaxNode,
}
impl UseTreeList {
    #[inline]
    pub fn use_trees(&self) -> AstChildren<UseTree> { support::children(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Variant {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Variant {}
impl ast::HasDocComments for Variant {}
impl ast::HasName for Variant {}
impl ast::HasVisibility for Variant {}
impl Variant {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn field_list(&self) -> Option<FieldList> { support::child(&self.syntax) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariantList {
    pub(crate) syntax: SyntaxNode,
}
impl VariantList {
    #[inline]
    pub fn variants(&self) -> AstChildren<Variant> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Visibility {
    pub(crate) syntax: SyntaxNode,
}
impl Visibility {
    #[inline]
    pub fn pub_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![pub]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhereClause {
    pub(crate) syntax: SyntaxNode,
}
impl WhereClause {
    #[inline]
    pub fn predicates(&self) -> AstChildren<WherePred> { support::children(&self.syntax) }
    #[inline]
    pub fn where_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![where]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WherePred {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasTypeBounds for WherePred {}
impl WherePred {
    #[inline]
    pub fn generic_param_list(&self) -> Option<GenericParamList> { support::child(&self.syntax) }
    #[inline]
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for WhileExpr {}
impl WhileExpr {
    #[inline]
    pub fn loop_body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn while_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![while]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WildcardPat {
    pub(crate) syntax: SyntaxNode,
}
impl WildcardPat {
    #[inline]
    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum CodeItem {
    Enum(Enum),
    Fn(Fn),
    Impl(Impl),
    Trait(Trait),
    TypeAlias(TypeAlias),
}
impl ast::HasAttrs for CodeItem {}
impl ast::HasDocComments for CodeItem {}
impl ast::HasGenericParams for CodeItem {}
impl ast::HasVisibility for CodeItem {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum DepPath {
    ExternalDepPath(ExternalDepPath),
    LocalDepPath(LocalDepPath),
    RepoDepPath(RepoDepPath),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    AsyncExpr(AsyncExpr),
    AwaitExpr(AwaitExpr),
    BinExpr(BinExpr),
    BlockExpr(BlockExpr),
    BreakExpr(BreakExpr),
    CallExpr(CallExpr),
    CastExpr(CastExpr),
    ClosureExpr(ClosureExpr),
    ContinueExpr(ContinueExpr),
    FieldExpr(FieldExpr),
    FnRefExpr(FnRefExpr),
    ForExpr(ForExpr),
    IfExpr(IfExpr),
    IndexExpr(IndexExpr),
    LetExpr(LetExpr),
    ListExpr(ListExpr),
    Literal(Literal),
    LoopExpr(LoopExpr),
    MapExpr(MapExpr),
    MatchExpr(MatchExpr),
    MethodCallExpr(MethodCallExpr),
    MutExpr(MutExpr),
    NegExpr(NegExpr),
    NotExpr(NotExpr),
    ParenExpr(ParenExpr),
    PathExpr(PathExpr),
    RangeExpr(RangeExpr),
    ReturnExpr(ReturnExpr),
    SetExpr(SetExpr),
    TryExpr(TryExpr),
    TupleExpr(TupleExpr),
    UnderscoreExpr(UnderscoreExpr),
    WhileExpr(WhileExpr),
}
impl ast::HasAttrs for Expr {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FieldList {
    RecordFieldList(RecordFieldList),
    TupleFieldList(TupleFieldList),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum GenericArg {
    AssocTypeArg(AssocTypeArg),
    ConstArg(ConstArg),
    TypeArg(TypeArg),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Pat {
    AliasedTuplePat(AliasedTuplePat),
    IdentPat(IdentPat),
    LiteralPat(LiteralPat),
    OrPat(OrPat),
    ParenPat(ParenPat),
    PathPat(PathPat),
    RangePat(RangePat),
    RecordPat(RecordPat),
    RestPat(RestPat),
    SlicePat(SlicePat),
    TuplePat(TuplePat),
    WildcardPat(WildcardPat),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    CodeItem(CodeItem),
    ExprStmt(ExprStmt),
    LetStmt(LetStmt),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Type {
    FnPtrType(FnPtrType),
    InferType(InferType),
    ListType(ListType),
    MapType(MapType),
    MutType(MutType),
    NeverType(NeverType),
    OptionType(OptionType),
    ParenType(ParenType),
    PathType(PathType),
    RecordType(RecordType),
    ResultType(ResultType),
    SetType(SetType),
    TupleType(TupleType),
    UnionType(UnionType),
    UnknownType(UnknownType),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasArgList {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasArgList for AnyHasArgList {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasAttrs {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for AnyHasAttrs {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasDocComments {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasDocComments for AnyHasDocComments {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasGenericArgs {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasGenericArgs for AnyHasGenericArgs {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasGenericParams {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasGenericParams for AnyHasGenericParams {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasName {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for AnyHasName {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasTypeBounds {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasTypeBounds for AnyHasTypeBounds {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasVisibility {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasVisibility for AnyHasVisibility {}
impl AstNode for AliasedTuplePat {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ALIASED_TUPLE_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Arg {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ARG }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ArgList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ARG_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for AssocItemList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ASSOC_ITEM_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for AssocTypeArg {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ASSOC_TYPE_ARG }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for AsyncExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ASYNC_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Attr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ATTR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for AwaitExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == AWAIT_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for BinExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == BIN_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for BlockExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == BLOCK_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for BreakExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == BREAK_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for CallExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CALL_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for CastExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CAST_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ClosureExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CLOSURE_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for CodeSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CODE_SECTION }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ConstArg {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CONST_ARG }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ContinueExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CONTINUE_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Dep {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == DEP }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for DepPathSegment {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == DEP_PATH_SEGMENT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Enum {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ENUM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ExprStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == EXPR_STMT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ExternalDepPath {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == EXTERNAL_DEP_PATH }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for FieldExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == FIELD_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Fn {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == FN }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for FnPtrType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == FN_PTR_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for FnRefExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == FN_REF_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ForExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for GenericArgList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == GENERIC_ARG_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for GenericParam {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == GENERIC_PARAM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for GenericParamList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == GENERIC_PARAM_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for IdentPat {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == IDENT_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for IfExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == IF_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Impl {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == IMPL }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for IndexExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == INDEX_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for InferType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == INFER_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for LetExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LET_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for LetStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LET_STMT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ListEntry {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LIST_ENTRY }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ListExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LIST_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ListType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LIST_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Literal {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LITERAL }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for LiteralPat {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LITERAL_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for LocalDepPath {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LOCAL_DEP_PATH }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for LoopExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LOOP_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MapEntry {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MAP_ENTRY }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MapExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MAP_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MapType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MAP_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MatchArm {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_ARM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MatchArmList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_ARM_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MatchExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MatchGuard {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_GUARD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MaybeSelfifiedArg {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MAYBE_SELFIFIED_ARG }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Meta {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == META }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MetaSection {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == META_SECTION }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MethodCallArgList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == METHOD_CALL_ARG_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MethodCallExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == METHOD_CALL_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MutExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MUT_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MutType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MUT_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Name {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NameRef {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME_REF }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NegExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NEG_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NeverType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NEVER_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NotExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NOT_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for OptionType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == OPTION_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for OrPat {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == OR_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Param {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PARAM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ParamList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PARAM_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ParenExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ParenPat {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ParenType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ParentDirDepPathSegment {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PARENT_DIR_DEP_PATH_SEGMENT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Path {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathPat {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathSegment {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_SEGMENT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RangeExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RANGE_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RangePat {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RANGE_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RecordExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RecordExprField {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_EXPR_FIELD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RecordExprFieldList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_EXPR_FIELD_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RecordField {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_FIELD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RecordFieldList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_FIELD_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RecordPat {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RecordPatField {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_PAT_FIELD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RecordType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RecordTypeField {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_TYPE_FIELD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Rename {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RENAME }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RepoDepPath {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == REPO_DEP_PATH }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RestPat {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == REST_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ResultType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RESULT_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RetType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RET_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ReturnExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RETURN_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SelfParam {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SELF_PARAM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SetEntry {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SET_ENTRY }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SetExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SET_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SetType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SET_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SlicePat {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SLICE_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SliceType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SLICE_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SourceFile {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SOURCE_FILE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for StmtList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STMT_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TokenTree {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TOKEN_TREE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Trait {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TRAIT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TryExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TRY_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TupleExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TupleField {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_FIELD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TupleFieldList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_FIELD_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TuplePat {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TupleType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TypeAlias {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ALIAS }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TypeArg {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ARG }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TypeBound {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_BOUND }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TypeBoundList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_BOUND_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TypeParam {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_PARAM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UnderscoreExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == UNDERSCORE_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UnionType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == UNION_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UnknownType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == UNKNOWN_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Use {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == USE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UseTree {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_TREE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UseTreeExpansion {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_TREE_EXPANSION }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UseTreeList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_TREE_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Variant {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VARIANT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for VariantList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VARIANT_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Visibility {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VISIBILITY }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for WhereClause {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == WHERE_CLAUSE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for WherePred {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == WHERE_PRED }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for WhileExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == WHILE_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for WildcardPat {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == WILDCARD_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Enum> for CodeItem {
    #[inline]
    fn from(node: Enum) -> CodeItem { CodeItem::Enum(node) }
}
impl From<Fn> for CodeItem {
    #[inline]
    fn from(node: Fn) -> CodeItem { CodeItem::Fn(node) }
}
impl From<Impl> for CodeItem {
    #[inline]
    fn from(node: Impl) -> CodeItem { CodeItem::Impl(node) }
}
impl From<Trait> for CodeItem {
    #[inline]
    fn from(node: Trait) -> CodeItem { CodeItem::Trait(node) }
}
impl From<TypeAlias> for CodeItem {
    #[inline]
    fn from(node: TypeAlias) -> CodeItem { CodeItem::TypeAlias(node) }
}
impl AstNode for CodeItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, ENUM | FN | IMPL | TRAIT | TYPE_ALIAS) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ENUM => CodeItem::Enum(Enum { syntax }),
            FN => CodeItem::Fn(Fn { syntax }),
            IMPL => CodeItem::Impl(Impl { syntax }),
            TRAIT => CodeItem::Trait(Trait { syntax }),
            TYPE_ALIAS => CodeItem::TypeAlias(TypeAlias { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            CodeItem::Enum(it) => &it.syntax,
            CodeItem::Fn(it) => &it.syntax,
            CodeItem::Impl(it) => &it.syntax,
            CodeItem::Trait(it) => &it.syntax,
            CodeItem::TypeAlias(it) => &it.syntax,
        }
    }
}
impl From<ExternalDepPath> for DepPath {
    #[inline]
    fn from(node: ExternalDepPath) -> DepPath { DepPath::ExternalDepPath(node) }
}
impl From<LocalDepPath> for DepPath {
    #[inline]
    fn from(node: LocalDepPath) -> DepPath { DepPath::LocalDepPath(node) }
}
impl From<RepoDepPath> for DepPath {
    #[inline]
    fn from(node: RepoDepPath) -> DepPath { DepPath::RepoDepPath(node) }
}
impl AstNode for DepPath {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, EXTERNAL_DEP_PATH | LOCAL_DEP_PATH | REPO_DEP_PATH)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            EXTERNAL_DEP_PATH => DepPath::ExternalDepPath(ExternalDepPath { syntax }),
            LOCAL_DEP_PATH => DepPath::LocalDepPath(LocalDepPath { syntax }),
            REPO_DEP_PATH => DepPath::RepoDepPath(RepoDepPath { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            DepPath::ExternalDepPath(it) => &it.syntax,
            DepPath::LocalDepPath(it) => &it.syntax,
            DepPath::RepoDepPath(it) => &it.syntax,
        }
    }
}
impl From<AsyncExpr> for Expr {
    #[inline]
    fn from(node: AsyncExpr) -> Expr { Expr::AsyncExpr(node) }
}
impl From<AwaitExpr> for Expr {
    #[inline]
    fn from(node: AwaitExpr) -> Expr { Expr::AwaitExpr(node) }
}
impl From<BinExpr> for Expr {
    #[inline]
    fn from(node: BinExpr) -> Expr { Expr::BinExpr(node) }
}
impl From<BlockExpr> for Expr {
    #[inline]
    fn from(node: BlockExpr) -> Expr { Expr::BlockExpr(node) }
}
impl From<BreakExpr> for Expr {
    #[inline]
    fn from(node: BreakExpr) -> Expr { Expr::BreakExpr(node) }
}
impl From<CallExpr> for Expr {
    #[inline]
    fn from(node: CallExpr) -> Expr { Expr::CallExpr(node) }
}
impl From<CastExpr> for Expr {
    #[inline]
    fn from(node: CastExpr) -> Expr { Expr::CastExpr(node) }
}
impl From<ClosureExpr> for Expr {
    #[inline]
    fn from(node: ClosureExpr) -> Expr { Expr::ClosureExpr(node) }
}
impl From<ContinueExpr> for Expr {
    #[inline]
    fn from(node: ContinueExpr) -> Expr { Expr::ContinueExpr(node) }
}
impl From<FieldExpr> for Expr {
    #[inline]
    fn from(node: FieldExpr) -> Expr { Expr::FieldExpr(node) }
}
impl From<FnRefExpr> for Expr {
    #[inline]
    fn from(node: FnRefExpr) -> Expr { Expr::FnRefExpr(node) }
}
impl From<ForExpr> for Expr {
    #[inline]
    fn from(node: ForExpr) -> Expr { Expr::ForExpr(node) }
}
impl From<IfExpr> for Expr {
    #[inline]
    fn from(node: IfExpr) -> Expr { Expr::IfExpr(node) }
}
impl From<IndexExpr> for Expr {
    #[inline]
    fn from(node: IndexExpr) -> Expr { Expr::IndexExpr(node) }
}
impl From<LetExpr> for Expr {
    #[inline]
    fn from(node: LetExpr) -> Expr { Expr::LetExpr(node) }
}
impl From<ListExpr> for Expr {
    #[inline]
    fn from(node: ListExpr) -> Expr { Expr::ListExpr(node) }
}
impl From<Literal> for Expr {
    #[inline]
    fn from(node: Literal) -> Expr { Expr::Literal(node) }
}
impl From<LoopExpr> for Expr {
    #[inline]
    fn from(node: LoopExpr) -> Expr { Expr::LoopExpr(node) }
}
impl From<MapExpr> for Expr {
    #[inline]
    fn from(node: MapExpr) -> Expr { Expr::MapExpr(node) }
}
impl From<MatchExpr> for Expr {
    #[inline]
    fn from(node: MatchExpr) -> Expr { Expr::MatchExpr(node) }
}
impl From<MethodCallExpr> for Expr {
    #[inline]
    fn from(node: MethodCallExpr) -> Expr { Expr::MethodCallExpr(node) }
}
impl From<MutExpr> for Expr {
    #[inline]
    fn from(node: MutExpr) -> Expr { Expr::MutExpr(node) }
}
impl From<NegExpr> for Expr {
    #[inline]
    fn from(node: NegExpr) -> Expr { Expr::NegExpr(node) }
}
impl From<NotExpr> for Expr {
    #[inline]
    fn from(node: NotExpr) -> Expr { Expr::NotExpr(node) }
}
impl From<ParenExpr> for Expr {
    #[inline]
    fn from(node: ParenExpr) -> Expr { Expr::ParenExpr(node) }
}
impl From<PathExpr> for Expr {
    #[inline]
    fn from(node: PathExpr) -> Expr { Expr::PathExpr(node) }
}
impl From<RangeExpr> for Expr {
    #[inline]
    fn from(node: RangeExpr) -> Expr { Expr::RangeExpr(node) }
}
impl From<ReturnExpr> for Expr {
    #[inline]
    fn from(node: ReturnExpr) -> Expr { Expr::ReturnExpr(node) }
}
impl From<SetExpr> for Expr {
    #[inline]
    fn from(node: SetExpr) -> Expr { Expr::SetExpr(node) }
}
impl From<TryExpr> for Expr {
    #[inline]
    fn from(node: TryExpr) -> Expr { Expr::TryExpr(node) }
}
impl From<TupleExpr> for Expr {
    #[inline]
    fn from(node: TupleExpr) -> Expr { Expr::TupleExpr(node) }
}
impl From<UnderscoreExpr> for Expr {
    #[inline]
    fn from(node: UnderscoreExpr) -> Expr { Expr::UnderscoreExpr(node) }
}
impl From<WhileExpr> for Expr {
    #[inline]
    fn from(node: WhileExpr) -> Expr { Expr::WhileExpr(node) }
}
impl AstNode for Expr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ASYNC_EXPR
                | AWAIT_EXPR
                | BIN_EXPR
                | BLOCK_EXPR
                | BREAK_EXPR
                | CALL_EXPR
                | CAST_EXPR
                | CLOSURE_EXPR
                | CONTINUE_EXPR
                | FIELD_EXPR
                | FN_REF_EXPR
                | FOR_EXPR
                | IF_EXPR
                | INDEX_EXPR
                | LET_EXPR
                | LIST_EXPR
                | LITERAL
                | LOOP_EXPR
                | MAP_EXPR
                | MATCH_EXPR
                | METHOD_CALL_EXPR
                | MUT_EXPR
                | NEG_EXPR
                | NOT_EXPR
                | PAREN_EXPR
                | PATH_EXPR
                | RANGE_EXPR
                | RETURN_EXPR
                | SET_EXPR
                | TRY_EXPR
                | TUPLE_EXPR
                | UNDERSCORE_EXPR
                | WHILE_EXPR
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ASYNC_EXPR => Expr::AsyncExpr(AsyncExpr { syntax }),
            AWAIT_EXPR => Expr::AwaitExpr(AwaitExpr { syntax }),
            BIN_EXPR => Expr::BinExpr(BinExpr { syntax }),
            BLOCK_EXPR => Expr::BlockExpr(BlockExpr { syntax }),
            BREAK_EXPR => Expr::BreakExpr(BreakExpr { syntax }),
            CALL_EXPR => Expr::CallExpr(CallExpr { syntax }),
            CAST_EXPR => Expr::CastExpr(CastExpr { syntax }),
            CLOSURE_EXPR => Expr::ClosureExpr(ClosureExpr { syntax }),
            CONTINUE_EXPR => Expr::ContinueExpr(ContinueExpr { syntax }),
            FIELD_EXPR => Expr::FieldExpr(FieldExpr { syntax }),
            FN_REF_EXPR => Expr::FnRefExpr(FnRefExpr { syntax }),
            FOR_EXPR => Expr::ForExpr(ForExpr { syntax }),
            IF_EXPR => Expr::IfExpr(IfExpr { syntax }),
            INDEX_EXPR => Expr::IndexExpr(IndexExpr { syntax }),
            LET_EXPR => Expr::LetExpr(LetExpr { syntax }),
            LIST_EXPR => Expr::ListExpr(ListExpr { syntax }),
            LITERAL => Expr::Literal(Literal { syntax }),
            LOOP_EXPR => Expr::LoopExpr(LoopExpr { syntax }),
            MAP_EXPR => Expr::MapExpr(MapExpr { syntax }),
            MATCH_EXPR => Expr::MatchExpr(MatchExpr { syntax }),
            METHOD_CALL_EXPR => Expr::MethodCallExpr(MethodCallExpr { syntax }),
            MUT_EXPR => Expr::MutExpr(MutExpr { syntax }),
            NEG_EXPR => Expr::NegExpr(NegExpr { syntax }),
            NOT_EXPR => Expr::NotExpr(NotExpr { syntax }),
            PAREN_EXPR => Expr::ParenExpr(ParenExpr { syntax }),
            PATH_EXPR => Expr::PathExpr(PathExpr { syntax }),
            RANGE_EXPR => Expr::RangeExpr(RangeExpr { syntax }),
            RETURN_EXPR => Expr::ReturnExpr(ReturnExpr { syntax }),
            SET_EXPR => Expr::SetExpr(SetExpr { syntax }),
            TRY_EXPR => Expr::TryExpr(TryExpr { syntax }),
            TUPLE_EXPR => Expr::TupleExpr(TupleExpr { syntax }),
            UNDERSCORE_EXPR => Expr::UnderscoreExpr(UnderscoreExpr { syntax }),
            WHILE_EXPR => Expr::WhileExpr(WhileExpr { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expr::AsyncExpr(it) => &it.syntax,
            Expr::AwaitExpr(it) => &it.syntax,
            Expr::BinExpr(it) => &it.syntax,
            Expr::BlockExpr(it) => &it.syntax,
            Expr::BreakExpr(it) => &it.syntax,
            Expr::CallExpr(it) => &it.syntax,
            Expr::CastExpr(it) => &it.syntax,
            Expr::ClosureExpr(it) => &it.syntax,
            Expr::ContinueExpr(it) => &it.syntax,
            Expr::FieldExpr(it) => &it.syntax,
            Expr::FnRefExpr(it) => &it.syntax,
            Expr::ForExpr(it) => &it.syntax,
            Expr::IfExpr(it) => &it.syntax,
            Expr::IndexExpr(it) => &it.syntax,
            Expr::LetExpr(it) => &it.syntax,
            Expr::ListExpr(it) => &it.syntax,
            Expr::Literal(it) => &it.syntax,
            Expr::LoopExpr(it) => &it.syntax,
            Expr::MapExpr(it) => &it.syntax,
            Expr::MatchExpr(it) => &it.syntax,
            Expr::MethodCallExpr(it) => &it.syntax,
            Expr::MutExpr(it) => &it.syntax,
            Expr::NegExpr(it) => &it.syntax,
            Expr::NotExpr(it) => &it.syntax,
            Expr::ParenExpr(it) => &it.syntax,
            Expr::PathExpr(it) => &it.syntax,
            Expr::RangeExpr(it) => &it.syntax,
            Expr::ReturnExpr(it) => &it.syntax,
            Expr::SetExpr(it) => &it.syntax,
            Expr::TryExpr(it) => &it.syntax,
            Expr::TupleExpr(it) => &it.syntax,
            Expr::UnderscoreExpr(it) => &it.syntax,
            Expr::WhileExpr(it) => &it.syntax,
        }
    }
}
impl From<RecordFieldList> for FieldList {
    #[inline]
    fn from(node: RecordFieldList) -> FieldList { FieldList::RecordFieldList(node) }
}
impl From<TupleFieldList> for FieldList {
    #[inline]
    fn from(node: TupleFieldList) -> FieldList { FieldList::TupleFieldList(node) }
}
impl AstNode for FieldList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, RECORD_FIELD_LIST | TUPLE_FIELD_LIST) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            RECORD_FIELD_LIST => FieldList::RecordFieldList(RecordFieldList { syntax }),
            TUPLE_FIELD_LIST => FieldList::TupleFieldList(TupleFieldList { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            FieldList::RecordFieldList(it) => &it.syntax,
            FieldList::TupleFieldList(it) => &it.syntax,
        }
    }
}
impl From<AssocTypeArg> for GenericArg {
    #[inline]
    fn from(node: AssocTypeArg) -> GenericArg { GenericArg::AssocTypeArg(node) }
}
impl From<ConstArg> for GenericArg {
    #[inline]
    fn from(node: ConstArg) -> GenericArg { GenericArg::ConstArg(node) }
}
impl From<TypeArg> for GenericArg {
    #[inline]
    fn from(node: TypeArg) -> GenericArg { GenericArg::TypeArg(node) }
}
impl AstNode for GenericArg {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, ASSOC_TYPE_ARG | CONST_ARG | TYPE_ARG) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ASSOC_TYPE_ARG => GenericArg::AssocTypeArg(AssocTypeArg { syntax }),
            CONST_ARG => GenericArg::ConstArg(ConstArg { syntax }),
            TYPE_ARG => GenericArg::TypeArg(TypeArg { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            GenericArg::AssocTypeArg(it) => &it.syntax,
            GenericArg::ConstArg(it) => &it.syntax,
            GenericArg::TypeArg(it) => &it.syntax,
        }
    }
}
impl From<AliasedTuplePat> for Pat {
    #[inline]
    fn from(node: AliasedTuplePat) -> Pat { Pat::AliasedTuplePat(node) }
}
impl From<IdentPat> for Pat {
    #[inline]
    fn from(node: IdentPat) -> Pat { Pat::IdentPat(node) }
}
impl From<LiteralPat> for Pat {
    #[inline]
    fn from(node: LiteralPat) -> Pat { Pat::LiteralPat(node) }
}
impl From<OrPat> for Pat {
    #[inline]
    fn from(node: OrPat) -> Pat { Pat::OrPat(node) }
}
impl From<ParenPat> for Pat {
    #[inline]
    fn from(node: ParenPat) -> Pat { Pat::ParenPat(node) }
}
impl From<PathPat> for Pat {
    #[inline]
    fn from(node: PathPat) -> Pat { Pat::PathPat(node) }
}
impl From<RangePat> for Pat {
    #[inline]
    fn from(node: RangePat) -> Pat { Pat::RangePat(node) }
}
impl From<RecordPat> for Pat {
    #[inline]
    fn from(node: RecordPat) -> Pat { Pat::RecordPat(node) }
}
impl From<RestPat> for Pat {
    #[inline]
    fn from(node: RestPat) -> Pat { Pat::RestPat(node) }
}
impl From<SlicePat> for Pat {
    #[inline]
    fn from(node: SlicePat) -> Pat { Pat::SlicePat(node) }
}
impl From<TuplePat> for Pat {
    #[inline]
    fn from(node: TuplePat) -> Pat { Pat::TuplePat(node) }
}
impl From<WildcardPat> for Pat {
    #[inline]
    fn from(node: WildcardPat) -> Pat { Pat::WildcardPat(node) }
}
impl AstNode for Pat {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ALIASED_TUPLE_PAT
                | IDENT_PAT
                | LITERAL_PAT
                | OR_PAT
                | PAREN_PAT
                | PATH_PAT
                | RANGE_PAT
                | RECORD_PAT
                | REST_PAT
                | SLICE_PAT
                | TUPLE_PAT
                | WILDCARD_PAT
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ALIASED_TUPLE_PAT => Pat::AliasedTuplePat(AliasedTuplePat { syntax }),
            IDENT_PAT => Pat::IdentPat(IdentPat { syntax }),
            LITERAL_PAT => Pat::LiteralPat(LiteralPat { syntax }),
            OR_PAT => Pat::OrPat(OrPat { syntax }),
            PAREN_PAT => Pat::ParenPat(ParenPat { syntax }),
            PATH_PAT => Pat::PathPat(PathPat { syntax }),
            RANGE_PAT => Pat::RangePat(RangePat { syntax }),
            RECORD_PAT => Pat::RecordPat(RecordPat { syntax }),
            REST_PAT => Pat::RestPat(RestPat { syntax }),
            SLICE_PAT => Pat::SlicePat(SlicePat { syntax }),
            TUPLE_PAT => Pat::TuplePat(TuplePat { syntax }),
            WILDCARD_PAT => Pat::WildcardPat(WildcardPat { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Pat::AliasedTuplePat(it) => &it.syntax,
            Pat::IdentPat(it) => &it.syntax,
            Pat::LiteralPat(it) => &it.syntax,
            Pat::OrPat(it) => &it.syntax,
            Pat::ParenPat(it) => &it.syntax,
            Pat::PathPat(it) => &it.syntax,
            Pat::RangePat(it) => &it.syntax,
            Pat::RecordPat(it) => &it.syntax,
            Pat::RestPat(it) => &it.syntax,
            Pat::SlicePat(it) => &it.syntax,
            Pat::TuplePat(it) => &it.syntax,
            Pat::WildcardPat(it) => &it.syntax,
        }
    }
}
impl From<CodeItem> for Stmt {
    #[inline]
    fn from(node: CodeItem) -> Stmt { Stmt::CodeItem(node) }
}
impl From<ExprStmt> for Stmt {
    #[inline]
    fn from(node: ExprStmt) -> Stmt { Stmt::ExprStmt(node) }
}
impl From<LetStmt> for Stmt {
    #[inline]
    fn from(node: LetStmt) -> Stmt { Stmt::LetStmt(node) }
}
impl From<FnPtrType> for Type {
    #[inline]
    fn from(node: FnPtrType) -> Type { Type::FnPtrType(node) }
}
impl From<InferType> for Type {
    #[inline]
    fn from(node: InferType) -> Type { Type::InferType(node) }
}
impl From<ListType> for Type {
    #[inline]
    fn from(node: ListType) -> Type { Type::ListType(node) }
}
impl From<MapType> for Type {
    #[inline]
    fn from(node: MapType) -> Type { Type::MapType(node) }
}
impl From<MutType> for Type {
    #[inline]
    fn from(node: MutType) -> Type { Type::MutType(node) }
}
impl From<NeverType> for Type {
    #[inline]
    fn from(node: NeverType) -> Type { Type::NeverType(node) }
}
impl From<OptionType> for Type {
    #[inline]
    fn from(node: OptionType) -> Type { Type::OptionType(node) }
}
impl From<ParenType> for Type {
    #[inline]
    fn from(node: ParenType) -> Type { Type::ParenType(node) }
}
impl From<PathType> for Type {
    #[inline]
    fn from(node: PathType) -> Type { Type::PathType(node) }
}
impl From<RecordType> for Type {
    #[inline]
    fn from(node: RecordType) -> Type { Type::RecordType(node) }
}
impl From<ResultType> for Type {
    #[inline]
    fn from(node: ResultType) -> Type { Type::ResultType(node) }
}
impl From<SetType> for Type {
    #[inline]
    fn from(node: SetType) -> Type { Type::SetType(node) }
}
impl From<TupleType> for Type {
    #[inline]
    fn from(node: TupleType) -> Type { Type::TupleType(node) }
}
impl From<UnionType> for Type {
    #[inline]
    fn from(node: UnionType) -> Type { Type::UnionType(node) }
}
impl From<UnknownType> for Type {
    #[inline]
    fn from(node: UnknownType) -> Type { Type::UnknownType(node) }
}
impl AstNode for Type {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            FN_PTR_TYPE
                | INFER_TYPE
                | LIST_TYPE
                | MAP_TYPE
                | MUT_TYPE
                | NEVER_TYPE
                | OPTION_TYPE
                | PAREN_TYPE
                | PATH_TYPE
                | RECORD_TYPE
                | RESULT_TYPE
                | SET_TYPE
                | TUPLE_TYPE
                | UNION_TYPE
                | UNKNOWN_TYPE
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            FN_PTR_TYPE => Type::FnPtrType(FnPtrType { syntax }),
            INFER_TYPE => Type::InferType(InferType { syntax }),
            LIST_TYPE => Type::ListType(ListType { syntax }),
            MAP_TYPE => Type::MapType(MapType { syntax }),
            MUT_TYPE => Type::MutType(MutType { syntax }),
            NEVER_TYPE => Type::NeverType(NeverType { syntax }),
            OPTION_TYPE => Type::OptionType(OptionType { syntax }),
            PAREN_TYPE => Type::ParenType(ParenType { syntax }),
            PATH_TYPE => Type::PathType(PathType { syntax }),
            RECORD_TYPE => Type::RecordType(RecordType { syntax }),
            RESULT_TYPE => Type::ResultType(ResultType { syntax }),
            SET_TYPE => Type::SetType(SetType { syntax }),
            TUPLE_TYPE => Type::TupleType(TupleType { syntax }),
            UNION_TYPE => Type::UnionType(UnionType { syntax }),
            UNKNOWN_TYPE => Type::UnknownType(UnknownType { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Type::FnPtrType(it) => &it.syntax,
            Type::InferType(it) => &it.syntax,
            Type::ListType(it) => &it.syntax,
            Type::MapType(it) => &it.syntax,
            Type::MutType(it) => &it.syntax,
            Type::NeverType(it) => &it.syntax,
            Type::OptionType(it) => &it.syntax,
            Type::ParenType(it) => &it.syntax,
            Type::PathType(it) => &it.syntax,
            Type::RecordType(it) => &it.syntax,
            Type::ResultType(it) => &it.syntax,
            Type::SetType(it) => &it.syntax,
            Type::TupleType(it) => &it.syntax,
            Type::UnionType(it) => &it.syntax,
            Type::UnknownType(it) => &it.syntax,
        }
    }
}
impl AnyHasArgList {
    #[inline]
    pub fn new<T: ast::HasArgList>(node: T) -> AnyHasArgList {
        AnyHasArgList {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasArgList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, CALL_EXPR) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasArgList { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<CallExpr> for AnyHasArgList {
    #[inline]
    fn from(node: CallExpr) -> AnyHasArgList {
        AnyHasArgList {
            syntax: node.syntax,
        }
    }
}
impl AnyHasAttrs {
    #[inline]
    pub fn new<T: ast::HasAttrs>(node: T) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasAttrs {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ASSOC_ITEM_LIST
                | ASYNC_EXPR
                | AWAIT_EXPR
                | BIN_EXPR
                | BLOCK_EXPR
                | BREAK_EXPR
                | CALL_EXPR
                | CAST_EXPR
                | CLOSURE_EXPR
                | CODE_SECTION
                | CONTINUE_EXPR
                | DEP
                | ENUM
                | FIELD_EXPR
                | FN
                | FN_REF_EXPR
                | FOR_EXPR
                | IDENT_PAT
                | IF_EXPR
                | IMPL
                | INDEX_EXPR
                | LET_EXPR
                | LET_STMT
                | LIST_ENTRY
                | LIST_EXPR
                | LITERAL
                | LOOP_EXPR
                | MAP_ENTRY
                | MAP_EXPR
                | MATCH_ARM
                | MATCH_ARM_LIST
                | MATCH_EXPR
                | META_SECTION
                | METHOD_CALL_EXPR
                | MUT_EXPR
                | NEG_EXPR
                | NOT_EXPR
                | PARAM
                | PAREN_EXPR
                | PATH_EXPR
                | RANGE_EXPR
                | RECORD_EXPR_FIELD
                | RECORD_EXPR_FIELD_LIST
                | RECORD_FIELD
                | RECORD_PAT_FIELD
                | RECORD_TYPE_FIELD
                | REST_PAT
                | RETURN_EXPR
                | SELF_PARAM
                | SET_ENTRY
                | SET_EXPR
                | STMT_LIST
                | TRAIT
                | TRY_EXPR
                | TUPLE_EXPR
                | TUPLE_FIELD
                | TYPE_ALIAS
                | TYPE_PARAM
                | UNDERSCORE_EXPR
                | VARIANT
                | WHILE_EXPR
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasAttrs { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<AssocItemList> for AnyHasAttrs {
    #[inline]
    fn from(node: AssocItemList) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<AsyncExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: AsyncExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<AwaitExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: AwaitExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<BinExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: BinExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<BlockExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: BlockExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<BreakExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: BreakExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<CallExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: CallExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<CastExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: CastExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<ClosureExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: ClosureExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<CodeSection> for AnyHasAttrs {
    #[inline]
    fn from(node: CodeSection) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<ContinueExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: ContinueExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<Dep> for AnyHasAttrs {
    #[inline]
    fn from(node: Dep) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<Enum> for AnyHasAttrs {
    #[inline]
    fn from(node: Enum) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<FieldExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: FieldExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<Fn> for AnyHasAttrs {
    #[inline]
    fn from(node: Fn) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<FnRefExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: FnRefExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<ForExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: ForExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<IdentPat> for AnyHasAttrs {
    #[inline]
    fn from(node: IdentPat) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<IfExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: IfExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<Impl> for AnyHasAttrs {
    #[inline]
    fn from(node: Impl) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<IndexExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: IndexExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<LetExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: LetExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<LetStmt> for AnyHasAttrs {
    #[inline]
    fn from(node: LetStmt) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<ListEntry> for AnyHasAttrs {
    #[inline]
    fn from(node: ListEntry) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<ListExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: ListExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<Literal> for AnyHasAttrs {
    #[inline]
    fn from(node: Literal) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<LoopExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: LoopExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<MapEntry> for AnyHasAttrs {
    #[inline]
    fn from(node: MapEntry) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<MapExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: MapExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<MatchArm> for AnyHasAttrs {
    #[inline]
    fn from(node: MatchArm) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<MatchArmList> for AnyHasAttrs {
    #[inline]
    fn from(node: MatchArmList) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<MatchExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: MatchExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<MetaSection> for AnyHasAttrs {
    #[inline]
    fn from(node: MetaSection) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<MethodCallExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: MethodCallExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<MutExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: MutExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<NegExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: NegExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<NotExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: NotExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<Param> for AnyHasAttrs {
    #[inline]
    fn from(node: Param) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<ParenExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: ParenExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<PathExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: PathExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<RangeExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: RangeExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<RecordExprField> for AnyHasAttrs {
    #[inline]
    fn from(node: RecordExprField) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<RecordExprFieldList> for AnyHasAttrs {
    #[inline]
    fn from(node: RecordExprFieldList) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<RecordField> for AnyHasAttrs {
    #[inline]
    fn from(node: RecordField) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<RecordPatField> for AnyHasAttrs {
    #[inline]
    fn from(node: RecordPatField) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<RecordTypeField> for AnyHasAttrs {
    #[inline]
    fn from(node: RecordTypeField) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<RestPat> for AnyHasAttrs {
    #[inline]
    fn from(node: RestPat) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<ReturnExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: ReturnExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<SelfParam> for AnyHasAttrs {
    #[inline]
    fn from(node: SelfParam) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<SetEntry> for AnyHasAttrs {
    #[inline]
    fn from(node: SetEntry) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<SetExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: SetExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<StmtList> for AnyHasAttrs {
    #[inline]
    fn from(node: StmtList) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<Trait> for AnyHasAttrs {
    #[inline]
    fn from(node: Trait) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<TryExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: TryExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<TupleExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: TupleExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<TupleField> for AnyHasAttrs {
    #[inline]
    fn from(node: TupleField) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<TypeAlias> for AnyHasAttrs {
    #[inline]
    fn from(node: TypeAlias) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<TypeParam> for AnyHasAttrs {
    #[inline]
    fn from(node: TypeParam) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<UnderscoreExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: UnderscoreExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<Variant> for AnyHasAttrs {
    #[inline]
    fn from(node: Variant) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl From<WhileExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: WhileExpr) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax,
        }
    }
}
impl AnyHasDocComments {
    #[inline]
    pub fn new<T: ast::HasDocComments>(node: T) -> AnyHasDocComments {
        AnyHasDocComments {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasDocComments {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            CODE_SECTION
                | ENUM
                | FN
                | IMPL
                | META_SECTION
                | RECORD_FIELD
                | RECORD_TYPE_FIELD
                | TRAIT
                | TUPLE_FIELD
                | TYPE_ALIAS
                | VARIANT
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasDocComments { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<CodeSection> for AnyHasDocComments {
    #[inline]
    fn from(node: CodeSection) -> AnyHasDocComments {
        AnyHasDocComments {
            syntax: node.syntax,
        }
    }
}
impl From<Enum> for AnyHasDocComments {
    #[inline]
    fn from(node: Enum) -> AnyHasDocComments {
        AnyHasDocComments {
            syntax: node.syntax,
        }
    }
}
impl From<Fn> for AnyHasDocComments {
    #[inline]
    fn from(node: Fn) -> AnyHasDocComments {
        AnyHasDocComments {
            syntax: node.syntax,
        }
    }
}
impl From<Impl> for AnyHasDocComments {
    #[inline]
    fn from(node: Impl) -> AnyHasDocComments {
        AnyHasDocComments {
            syntax: node.syntax,
        }
    }
}
impl From<MetaSection> for AnyHasDocComments {
    #[inline]
    fn from(node: MetaSection) -> AnyHasDocComments {
        AnyHasDocComments {
            syntax: node.syntax,
        }
    }
}
impl From<RecordField> for AnyHasDocComments {
    #[inline]
    fn from(node: RecordField) -> AnyHasDocComments {
        AnyHasDocComments {
            syntax: node.syntax,
        }
    }
}
impl From<RecordTypeField> for AnyHasDocComments {
    #[inline]
    fn from(node: RecordTypeField) -> AnyHasDocComments {
        AnyHasDocComments {
            syntax: node.syntax,
        }
    }
}
impl From<Trait> for AnyHasDocComments {
    #[inline]
    fn from(node: Trait) -> AnyHasDocComments {
        AnyHasDocComments {
            syntax: node.syntax,
        }
    }
}
impl From<TupleField> for AnyHasDocComments {
    #[inline]
    fn from(node: TupleField) -> AnyHasDocComments {
        AnyHasDocComments {
            syntax: node.syntax,
        }
    }
}
impl From<TypeAlias> for AnyHasDocComments {
    #[inline]
    fn from(node: TypeAlias) -> AnyHasDocComments {
        AnyHasDocComments {
            syntax: node.syntax,
        }
    }
}
impl From<Variant> for AnyHasDocComments {
    #[inline]
    fn from(node: Variant) -> AnyHasDocComments {
        AnyHasDocComments {
            syntax: node.syntax,
        }
    }
}
impl AnyHasGenericArgs {
    #[inline]
    pub fn new<T: ast::HasGenericArgs>(node: T) -> AnyHasGenericArgs {
        AnyHasGenericArgs {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasGenericArgs {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, ASSOC_TYPE_ARG | METHOD_CALL_EXPR | PATH_SEGMENT)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasGenericArgs { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<AssocTypeArg> for AnyHasGenericArgs {
    #[inline]
    fn from(node: AssocTypeArg) -> AnyHasGenericArgs {
        AnyHasGenericArgs {
            syntax: node.syntax,
        }
    }
}
impl From<MethodCallExpr> for AnyHasGenericArgs {
    #[inline]
    fn from(node: MethodCallExpr) -> AnyHasGenericArgs {
        AnyHasGenericArgs {
            syntax: node.syntax,
        }
    }
}
impl From<PathSegment> for AnyHasGenericArgs {
    #[inline]
    fn from(node: PathSegment) -> AnyHasGenericArgs {
        AnyHasGenericArgs {
            syntax: node.syntax,
        }
    }
}
impl AnyHasGenericParams {
    #[inline]
    pub fn new<T: ast::HasGenericParams>(node: T) -> AnyHasGenericParams {
        AnyHasGenericParams {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasGenericParams {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, ENUM | FN | IMPL | TRAIT | TYPE_ALIAS) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasGenericParams { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Enum> for AnyHasGenericParams {
    #[inline]
    fn from(node: Enum) -> AnyHasGenericParams {
        AnyHasGenericParams {
            syntax: node.syntax,
        }
    }
}
impl From<Fn> for AnyHasGenericParams {
    #[inline]
    fn from(node: Fn) -> AnyHasGenericParams {
        AnyHasGenericParams {
            syntax: node.syntax,
        }
    }
}
impl From<Impl> for AnyHasGenericParams {
    #[inline]
    fn from(node: Impl) -> AnyHasGenericParams {
        AnyHasGenericParams {
            syntax: node.syntax,
        }
    }
}
impl From<Trait> for AnyHasGenericParams {
    #[inline]
    fn from(node: Trait) -> AnyHasGenericParams {
        AnyHasGenericParams {
            syntax: node.syntax,
        }
    }
}
impl From<TypeAlias> for AnyHasGenericParams {
    #[inline]
    fn from(node: TypeAlias) -> AnyHasGenericParams {
        AnyHasGenericParams {
            syntax: node.syntax,
        }
    }
}
impl AnyHasName {
    #[inline]
    pub fn new<T: ast::HasName>(node: T) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasName {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ENUM | FN
                | IDENT_PAT
                | RECORD_FIELD
                | RECORD_TYPE_FIELD
                | RENAME
                | SELF_PARAM
                | TRAIT
                | TYPE_ALIAS
                | TYPE_PARAM
                | VARIANT
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasName { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Enum> for AnyHasName {
    #[inline]
    fn from(node: Enum) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax,
        }
    }
}
impl From<Fn> for AnyHasName {
    #[inline]
    fn from(node: Fn) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax,
        }
    }
}
impl From<IdentPat> for AnyHasName {
    #[inline]
    fn from(node: IdentPat) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax,
        }
    }
}
impl From<RecordField> for AnyHasName {
    #[inline]
    fn from(node: RecordField) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax,
        }
    }
}
impl From<RecordTypeField> for AnyHasName {
    #[inline]
    fn from(node: RecordTypeField) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax,
        }
    }
}
impl From<Rename> for AnyHasName {
    #[inline]
    fn from(node: Rename) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax,
        }
    }
}
impl From<SelfParam> for AnyHasName {
    #[inline]
    fn from(node: SelfParam) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax,
        }
    }
}
impl From<Trait> for AnyHasName {
    #[inline]
    fn from(node: Trait) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax,
        }
    }
}
impl From<TypeAlias> for AnyHasName {
    #[inline]
    fn from(node: TypeAlias) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax,
        }
    }
}
impl From<TypeParam> for AnyHasName {
    #[inline]
    fn from(node: TypeParam) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax,
        }
    }
}
impl From<Variant> for AnyHasName {
    #[inline]
    fn from(node: Variant) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax,
        }
    }
}
impl AnyHasTypeBounds {
    #[inline]
    pub fn new<T: ast::HasTypeBounds>(node: T) -> AnyHasTypeBounds {
        AnyHasTypeBounds {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasTypeBounds {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ASSOC_TYPE_ARG | TRAIT | TYPE_ALIAS | TYPE_PARAM | WHERE_PRED
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasTypeBounds { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<AssocTypeArg> for AnyHasTypeBounds {
    #[inline]
    fn from(node: AssocTypeArg) -> AnyHasTypeBounds {
        AnyHasTypeBounds {
            syntax: node.syntax,
        }
    }
}
impl From<Trait> for AnyHasTypeBounds {
    #[inline]
    fn from(node: Trait) -> AnyHasTypeBounds {
        AnyHasTypeBounds {
            syntax: node.syntax,
        }
    }
}
impl From<TypeAlias> for AnyHasTypeBounds {
    #[inline]
    fn from(node: TypeAlias) -> AnyHasTypeBounds {
        AnyHasTypeBounds {
            syntax: node.syntax,
        }
    }
}
impl From<TypeParam> for AnyHasTypeBounds {
    #[inline]
    fn from(node: TypeParam) -> AnyHasTypeBounds {
        AnyHasTypeBounds {
            syntax: node.syntax,
        }
    }
}
impl From<WherePred> for AnyHasTypeBounds {
    #[inline]
    fn from(node: WherePred) -> AnyHasTypeBounds {
        AnyHasTypeBounds {
            syntax: node.syntax,
        }
    }
}
impl AnyHasVisibility {
    #[inline]
    pub fn new<T: ast::HasVisibility>(node: T) -> AnyHasVisibility {
        AnyHasVisibility {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasVisibility {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ENUM | FN | IMPL | TRAIT | TUPLE_FIELD | TYPE_ALIAS | VARIANT
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasVisibility { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Enum> for AnyHasVisibility {
    #[inline]
    fn from(node: Enum) -> AnyHasVisibility {
        AnyHasVisibility {
            syntax: node.syntax,
        }
    }
}
impl From<Fn> for AnyHasVisibility {
    #[inline]
    fn from(node: Fn) -> AnyHasVisibility {
        AnyHasVisibility {
            syntax: node.syntax,
        }
    }
}
impl From<Impl> for AnyHasVisibility {
    #[inline]
    fn from(node: Impl) -> AnyHasVisibility {
        AnyHasVisibility {
            syntax: node.syntax,
        }
    }
}
impl From<Trait> for AnyHasVisibility {
    #[inline]
    fn from(node: Trait) -> AnyHasVisibility {
        AnyHasVisibility {
            syntax: node.syntax,
        }
    }
}
impl From<TupleField> for AnyHasVisibility {
    #[inline]
    fn from(node: TupleField) -> AnyHasVisibility {
        AnyHasVisibility {
            syntax: node.syntax,
        }
    }
}
impl From<TypeAlias> for AnyHasVisibility {
    #[inline]
    fn from(node: TypeAlias) -> AnyHasVisibility {
        AnyHasVisibility {
            syntax: node.syntax,
        }
    }
}
impl From<Variant> for AnyHasVisibility {
    #[inline]
    fn from(node: Variant) -> AnyHasVisibility {
        AnyHasVisibility {
            syntax: node.syntax,
        }
    }
}
impl std::fmt::Display for CodeItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DepPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GenericArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Pat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Stmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AliasedTuplePat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Arg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ArgList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssocItemList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssocTypeArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AsyncExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Attr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AwaitExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BinExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BlockExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BreakExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CastExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClosureExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CodeSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ConstArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ContinueExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Dep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DepPathSegment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Enum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExprStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExternalDepPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FieldExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Fn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FnPtrType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FnRefExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ForExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GenericArgList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GenericParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GenericParamList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IfExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Impl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IndexExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InferType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Literal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LiteralPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LocalDepPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LoopExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MapEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MapExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MapType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchArmList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchGuard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MaybeSelfifiedArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Meta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MetaSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MethodCallArgList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MethodCallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MutExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MutType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Name {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NameRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NegExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NeverType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NotExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OptionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OrPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Param {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParamList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParenExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParenPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParenType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParentDirDepPathSegment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Path {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathSegment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RangeExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RangePat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RecordExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RecordExprField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RecordExprFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RecordField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RecordFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RecordPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RecordPatField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RecordType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RecordTypeField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Rename {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RepoDepPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RestPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ResultType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RetType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ReturnExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SelfParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SetEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SetExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SetType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SlicePat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SliceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SourceFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StmtList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TokenTree {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Trait {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TupleExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TupleField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TupleFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TuplePat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TupleType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeAlias {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeBound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeBoundList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UnderscoreExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UnionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UnknownType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Use {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UseTree {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UseTreeExpansion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UseTreeList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Variant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VariantList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Visibility {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WhereClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WherePred {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WhileExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WildcardPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
